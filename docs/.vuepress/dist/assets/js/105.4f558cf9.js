(window.webpackJsonp=window.webpackJsonp||[]).push([[105],{493:function(t,n,e){"use strict";e.r(n);var a=e(54),s=Object(a.a)({},(function(){var t=this,n=t.$createElement,e=t._self._c||n;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("h1",{attrs:{id:"react滚动加载实现"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#react滚动加载实现"}},[t._v("#")]),t._v(" React滚动加载实现")]),t._v(" "),e("p",[t._v("在我个人博客中文章列表，采用滚动加载的方式显示文章")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("  componentDidMount() {\n    if (this.props.location.pathname === '/hot') {\n      this.setState(\n        {\n          likes: true,\n        },\n        () => {\n          this.handleSearch();\n        },\n      );\n    } else {\n      this.handleSearch();\n    }\n    window.onscroll = () => {\n      if (getScrollTop() + getWindowHeight() > getDocumentHeight() - 100) {\n        // 如果不是已经没有数据了，都可以继续滚动加载\n        if (this.state.isLoadEnd === false && this.state.isLoading === false) {\n          this.handleSearch();\n        }\n      }\n    };\n\n    document.addEventListener('scroll', lazyload);\n  }\n")])])]),e("p",[t._v("为当前页面的页面滚动事件添加处理函数。")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("window.onscroll = funcRef\n")])])]),e("p",[t._v("获取页面顶部被卷起来的高度")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export function getScrollTop() {\n  return Math.max(\n    //chrome\n    document.body.scrollTop,\n    //firefox/IE\n    document.documentElement.scrollTop,\n  );\n}\n")])])]),e("p",[t._v("获取浏览器视口的高度")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export function getWindowHeight() {\n  return document.compatMode === 'CSS1Compat'\n    ? document.documentElement.clientHeight\n    : document.body.clientHeight;\n}\n")])])]),e("p",[t._v("获取页面文档的总高度")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export function getDocumentHeight() {\n  //现代浏览器（IE9+和其他浏览器）和IE8的document.body.scrollHeight和document.documentElement.scrollHeight都可以\n  return Math.max(\n    document.body.scrollHeight,\n    document.documentElement.scrollHeight,\n  );\n}\n")])])]),e("p",[t._v("lazyload")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("// 用新的 throttle 包装 scroll 的回调\nconst lazyload = throttle(() => {\n  // 获取所有的图片标签\n  const imgs = document.querySelectorAll('#list .wrap-img img');\n  // num 用于统计当前显示到了哪一张图片，避免每次都从第一张图片开始检查是否露出\n  let num = 0;\n  for (let i = num; i < imgs.length; i++) {\n    // 用可视区域高度减去元素顶部距离可视区域顶部的高度\n    let distance = viewHeight - imgs[i].getBoundingClientRect().top;\n    // 如果可视区域高度大于等于元素顶部距离可视区域顶部的高度，说明元素露出\n    if (distance >= 100) {\n      // 给元素写入真实的 src，展示图片\n      let hasLaySrc = imgs[i].getAttribute('data-has-lazy-src');\n      if (hasLaySrc === 'false') {\n        imgs[i].src = imgs[i].getAttribute('data-src');\n        imgs[i].setAttribute('data-has-lazy-src', true);\n      }\n      // 前 i 张图片已经加载完毕，下次从第 i+1 张开始检查是否露出\n      num = i + 1;\n    }\n  }\n}, 1000);\n")])])]),e("p",[t._v("throttle fn是我们需要包装的事件回调, delay是时间间隔的阈值")]),t._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[t._v("export function throttle(fn, delay) {\n  // last为上一次触发回调的时间, timer是定时器\n  let last = 0,\n    timer = null;\n  // 将throttle处理结果当作函数返回\n\n  return function() {\n    // 保留调用时的this上下文\n    let context = this;\n    // 保留调用时传入的参数\n    let args = arguments;\n    // 记录本次触发回调的时间\n    let now = +new Date();\n\n    // 判断上次触发的时间和本次触发的时间差是否小于时间间隔的阈值\n    if (now - last < delay) {\n      // 如果时间间隔小于我们设定的时间间隔阈值，则为本次触发操作设立一个新的定时器\n      clearTimeout(timer);\n      timer = setTimeout(function() {\n        last = now;\n        fn.apply(context, args);\n      }, delay);\n    } else {\n      // 如果时间间隔超出了我们设定的时间间隔阈值，那就不等了，无论如何要反馈给用户一次响应\n      last = now;\n      fn.apply(context, args);\n    }\n  };\n}\n")])])])])}),[],!1,null,null,null);n.default=s.exports}}]);